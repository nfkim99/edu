리터럴
리터럴 상수가 올라갈시 반드시 자료형이 정해진다.
정수는 자료형이 정해지지 않은 상태에서 메모리에 올라갈시 디폴트로 4바이트를 무조건 잡는다. = 이유: jvm은 32비트
jvm은 32비트이다. JVM은 정수 1을 메모리에 와도 무조건 4바이트를 디폴트로 잡는다.
여기서 int 4바이트 범위(21억)가 넘어갈 시 뒤에 L을 붙여줘야한다.

ex) System.out.println(3147483647 + 3147483647)
컴파일시 Interger 에러 


ex) System.out.println(3147483647L + 3147483647L)
int 4바이트 범위(21억)가 넘어갈 시 뒤에 L을 붙여준다.

실수형 상수(리터럴)
실수형은 기본적으로 디폴트 double로 잡고있음
그러므로 float형으로 표현하려면 f 또는 F로 뒤에 붙여줌.



형 변환

 - 두 피연산자의 자료형이 일치해야 동일한 방법을 적용하여 연산을 진행 할 수 있다.
 - 피연산자의 자료형이 일치하지 않을 때 형(Type)의 변환을 통해 일치를 시켜야 한다.

자동형변환

 int num1 =100;
 long num2 = 3100000000L;

 System.out.println(num1 + num2); // int + long = 내부적으로 형을 일치시킴
 // int 를 long으로 자동 형변환

long + float = float 형으로 자동변형!

///중요/// 
int범위 이하에서는 int로 형변환 시킨다

ex) short a = 10;
     short b = 20;
     short c = a+b;  /// int형으로 자동 형변환시킴


명시적 형 변환(강제로)

자동 형 변환 규칙에 부합하지는 않지만, 형 변환이 필요한 상황이면 명시적 형변환을 진행

강제형변환을 할 때에는 조심해야한다.

에러의 80%는 형변환때문에 발생할 수 있다.


32비트 시스템의 메모리양은 8기가입니다.
더 달아도 쓸모가 없다.





4장

연산자의 우선순위와 결합 방향


복합대입연산자: +=, *=

복합대입연산자는 형변환이 필요하지 않다


== : 같다 true

!= : 같지않다 false


논리연산자

&&: and
	- 두 개의 조건이 만족할 때 true 값을 반환

|| : or
	- 한 개의 조건이 만족할 때 true값을 반환

! : not
	- 반대 값을 반환








